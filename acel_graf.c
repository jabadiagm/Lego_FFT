//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "AdvancedSensors.c"    // include library files
// tercera prueba. FFT
#define tamanio_buffer_circular 2000
#define tamanio_buffer_fft 1024
#define T 0.010 //periodo de muestreo
int buffer_circular[tamanio_buffer_circular];
float REX[tamanio_buffer_fft];
float IMX[tamanio_buffer_fft];
int N=tamanio_buffer_fft;
int contador_buffer_circular=0;
int nXAxis;
int nYAxis;
int nZAxis;
float maximo_amplitud;
float maximo_frecuencia;
float velocidad_giro; //usada en el motor
tSensors  puerto_acelerometro;

void FFT()
{
  float pi=3.14159265; //Set constants
  int NM1;
  int ND2;
  int M;
  int J;
  int i;
  int K;
  int L;
  int LE;
  int LE2;
  int JM1;
  int IP;
  float TR;
  float TI;
  float UR;
  float UI;
  float SR;
  float SI;
  int contador;

  //1000 'THE FAST FOURIER TRANSFORM
  //'copyright © 1997-1999 by California Technical Publishing
  //'published with  permission from Steven W Smith, www.dspguide.com
  //'GUI by logix4u , www.logix4u.net
  //'modified by logix4u, www.logix4.net
  //adaptado por mi ;-)
  //1010 'Upon entry, N contains the number of points in the DFT, REX[ ] and
  //1020 'IMX[ ] contain the real and imaginary parts of the input. Upon return,
  //1030 'REX[ ] and IMX[ ] contain the DFT output. All signals run from 0 to N-1.
  NM1 = N - 1;
  ND2 = N / 2;
  M = (int)(log(N) / log(2));
  J = ND2;
  for (i=1;i<=(N-2);i++) { //Bit reversal sorting
    if (i < J) {
      TR = REX[J];
      TI = IMX[J];
      REX[J] = REX[i];
      IMX[J] = IMX[i];
      REX[i] = TR;
      IMX[i] = TI;
     }
     K = ND2;
     while (K <= J) {
      J = J - K;
      K = K / 2;
     }
     J = J + K;
  }
  for (L=1;L<=M;L++) { //Loop for each stage
    LE=1<<L; //LE = 2 ^ L;
    LE2 = LE / 2;
    UR = 1;
    UI = 0;
    SR = cos(pi / LE2); //Calculate sine & cosine values
    SI = -sin(pi / LE2);
    for (J = 1; J<=LE2;J++) {//'Loop for each sub DFT
      JM1 = J - 1;
      for (i = JM1;i<= NM1; i+=LE) { //Loop for each butterfly
        IP = i + LE2;
        TR = REX[IP] * UR - IMX[IP] * UI; //Butterfly calculation
        TI = REX[IP] * UI + IMX[IP] * UR;
        REX[IP] = REX[i] - TR;
        IMX[IP] = IMX[i] - TI;
        REX[i] = REX[i] + TR;
        IMX[i] = IMX[i] + TI;
      }
      TR = UR;
      UR = TR * SR - UI * SI;
      UI = TR * SI + UI * SR;
    }
  }
  //acondicionamiento final. REX[] pasa a tener el modulo,
  //y IMX[] contiene la frecuencia correspondiente
  for (contador=0; contador<tamanio_buffer_fft;contador++) {
    //valor de pico, en g's (200 = 1g)
    REX[contador]=sqrt(REX[contador]*REX[contador]+IMX[contador]*IMX[contador])/tamanio_buffer_fft*2;
    REX[contador]=REX[contador]/200;
    IMX[contador]=contador/(tamanio_buffer_fft*T);
  }

}

task llenado_buffer()
{
  //toma muestras del acelerometro al ritmo regular marcado por
  //el periodo de muestreo. los datos se almacenan en un buffer circular
  //int contador;
  int retardo; //periodo de muestreo
  retardo=1000*T;
  nSchedulePriority = kHighPriority; //tarea principal
  while (1) {
    wait1Msec(retardo);
    getAccel(puerto_acelerometro, nXAxis, nYAxis, nZAxis);
    buffer_circular[contador_buffer_circular]=nXAxis;
    //buffer_circular[contador_buffer_circular]=200*sin(contador*0.062831*1); //1Hz
    //contador++;
    //if (contador>10000) contador=0;
    contador_buffer_circular++;
    if (contador_buffer_circular==tamanio_buffer_circular) contador_buffer_circular=0;

  }
 }

 task control_motor()
 {
   //ajusta la velocidad de giro del motor de prueba conectado al acelerometro
   //para comprobar la FFT
   nSchedulePriority = kLowPriority; //tarea secundaria, baja prioridad
   nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg; // enables motor speed regulation
   motor[motorA]=50;
   while (1) {
     nMotorEncoder[motorA]=0;
     wait1Msec(1000);
     velocidad_giro=(float)nMotorEncoder[motorA]/360; //vueltas/seg = hercios
     if (nNxtButtonPressed==1) motor[motorA]+=2;
     if (nNxtButtonPressed==2) motor[motorA]-=2;
   }
 }
 void inicializar_buffer()
 {
   int contador;
  //borra el contenido del buffer de FFT
  for (contador=0;contador<tamanio_buffer_fft;contador++) {
    REX[contador]=0;
    IMX[contador]=0;
  }
  for (contador=0;contador<tamanio_buffer_circular;contador++) {
    buffer_circular[contador]=0;
  }

/*  //relleno con valor senoidal
  for (contador = 1;contador<tamanio_buffer_circular;contador++) {
    buffer_circular[contador]=200*sin(contador*0.062831); //samp_buf(cnt) = samp_buf(cnt) + (ampl * Sin(2 * 3.141592658 * Frequency * (cnt / sample_rate)))
  } */

 }

void rellenar_buffer_fft()
{
  //toma los ultimos bytes almacenados en el buffer circular y los copia
  //en el buffer de trabajo de la FFT
  int contador;
  int contador2;
  int contador_buffer_circular_copia; //el contador puede cambiar mientras se ejecuta esta rutina
  contador_buffer_circular_copia=contador_buffer_circular-tamanio_buffer_fft;
  if (contador_buffer_circular_copia<0) contador_buffer_circular_copia+=tamanio_buffer_circular;
  if ((contador_buffer_circular_copia+tamanio_buffer_fft)<=tamanio_buffer_circular) { //la zona a copiar no da la vuelta
    for (contador=0;contador<tamanio_buffer_fft;contador++) {
      REX[contador]=buffer_circular[contador_buffer_circular_copia+contador];
      IMX[contador]=0;
    }
  } else { //el area a copiar no es continua, empieza al final del buffer circular
    contador2=0;
    //primera parte, final del buffer circular
    for (contador=contador_buffer_circular_copia;contador<tamanio_buffer_circular;contador++) {
      REX[contador2]=buffer_circular[contador];
      IMX[contador2]=0;
      contador2++;
    }
    //segunda parte, principio del buffer
    for (contador=0;contador2<tamanio_buffer_fft;contador++) {
      REX[contador2]=buffer_circular[contador];
      IMX[contador2]=0;
      contador2++;
    }
  }
}
void encontrar_pico_fft ()
{
  //recorre los resultados y encuentra el maximo
  int contador;
  maximo_amplitud=0;
  maximo_frecuencia=0;
  for (contador=1;contador<(tamanio_buffer_fft/2);contador++) {
     if (REX[contador]>maximo_amplitud) {
         maximo_amplitud=REX[contador];
         maximo_frecuencia=IMX[contador];
     }
  }
}

task main()
{
  //rutina de calculo de FFT y salida de datos
  int contador;
  //pico de la FFT y frecuencia de pico
  nSchedulePriority = kLowPriority; //tarea principal
  while (!findSensor(puerto_acelerometro, "HITECHNC", "Accel.  "))
	{
    wait1Msec(100);
  }
  SensorType[puerto_acelerometro] = sensorI2CHiTechnicAccel; // Configure the sensor
  inicializar_buffer();
  StartTask(control_motor);
  StartTask(llenado_buffer);
  while (1)
  {
      rellenar_buffer_fft(); //captura una ventana de datos
      FFT();
      //obtiene el pico de la FFT
      encontrar_pico_fft();
      eraseDisplay();
      nxtDisplayString(1, "Pico %1.2f G", maximo_amplitud);
      nxtDisplayString(2, "F %2.3f Hz", maximo_frecuencia);
      nxtDisplayString(3, "Real %2.3f Hz", velocidad_giro);
      //dibuja la grafica contenida en el buffer
      for (contador=1;contador<100;contador++) {
        nxtDrawLine(contador,0,contador,(int)(REX[contador]*200));
      }

  }
}
